<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="shortcut icon" type="image/png" href="favicon.png">
    <script src="https://cdn.counter.dev/script.js" data-id="ad78a2da-30a4-45d5-b433-ebc0ee739447" data-utcoffset="2"></script>I     <link rel="shortcut icon" type="image/x-icon" href="favicon.png">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>wmr?</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace;
            background: #0a0a0a;
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            color: #e0e0e0;
            margin-bottom: 30px;
            border-bottom: 1px solid #2a2a2a;
            padding-bottom: 20px;
        }
        
        .header h1 {
            font-size: 1.8rem;
            margin-bottom: 10px;
            font-weight: 400;
            letter-spacing: 2px;
        }
        
        .header p {
            font-size: 0.9rem;
            opacity: 0.6;
        }
        
        .current-date {
            margin-top: 10px;
            font-size: 0.8rem;
            color: #888;
        }
        
        .upload-section {
            background: #151515;
            border: 1px solid #2a2a2a;
            padding: 30px;
            margin-bottom: 30px;
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        .input-group:last-child {
            margin-bottom: 0;
        }
        
        .file-input-wrapper {
            position: relative;
            display: inline-block;
            cursor: pointer;
            width: 100%;
        }
        
        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }
        
        .file-input-label {
            display: block;
            padding: 15px;
            background: #0a0a0a;
            color: #e0e0e0;
            border: 1px dashed #4a4a4a;
            text-align: center;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .file-input-label:hover {
            border-color: #e0e0e0;
            background: #1a1a1a;
        }
        
        .url-input-wrapper {
            display: flex;
            gap: 10px;
        }
        
        .url-input {
            flex: 1;
            padding: 12px;
            background: #0a0a0a;
            color: #e0e0e0;
            border: 1px solid #2a2a2a;
            font-family: inherit;
            font-size: 0.85rem;
        }
        
        .url-input:focus {
            outline: none;
            border-color: #4a4a4a;
        }
        
        .fetch-button {
            padding: 12px 20px;
            background: #0a0a0a;
            color: #e0e0e0;
            border: 1px solid #2a2a2a;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s ease;
        }
        
        .fetch-button:hover {
            border-color: #4a4a4a;
            background: #1a1a1a;
        }
        
        .divider {
            text-align: center;
            margin: 20px 0;
            color: #666;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .results-section {
            display: none;
        }
        
        .next-week-section {
            background: #151515;
            border: 1px solid #2a2a2a;
            padding: 25px;
            margin-bottom: 30px;
        }
        
        .next-week-section h2 {
            color: #e0e0e0;
            margin-bottom: 20px;
            font-size: 1.1rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 300;
        }
        
        .day-schedule {
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid #2a2a2a;
        }
        
        .day-schedule:last-child {
            border-bottom: none;
        }
        
        .day-schedule.today {
            padding: 15px;
            margin: 15px 0;
        }

        .day-header {
            color: #e0e0e0;
            font-size: 0.95rem;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .day-header.today {
            color: #44ff44;
            font-weight: bold;
        }

        .today-indicator {
            background: #44ff44;
            color: #0a0a0a;
            padding: 2px 8px;
            font-size: 0.7rem;
            font-weight: bold;
            text-transform: uppercase;
            border-radius: 2px;
        }

        .current-time {
            color: #ffaa00;
            font-size: 0.8rem;
            margin-left: 10px;
        }
        
        .day-date {
            color: #666;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .day-events {
            margin-left: 20px;
        }
        
        .day-event {
            padding: 5px 0;
            color: #888;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .day-event.current {
            color: #44ff44;
            background: #0a1a0a;
            padding: 8px;
            margin: 3px 0;
            border-left: 3px solid #44ff44;
        }

        .day-event.upcoming {
            color: #ffaa00;
            background: #1a0a0a;
            padding: 6px;
            margin: 2px 0;
            border-left: 2px solid #ffaa00;
        }
        
        .day-event.next {
            color: #4488ff;
            background: #0a0a1a;
            padding: 4px;
            margin: 1px 0;
            border-left: 1px solid #4488ff;
        }

        .day-event.done {
            text-decoration: line-through;
        }

        .day-event.exam {
            color: #ff8800 !important;
            font-weight: bold;
        }

        .day-event.exam .event-time {
            color: #ffaa44;
        }

        .event-indicator {
            font-weight: bold;
            font-size: 1rem;
            margin-right: 5px;
        }
        
        .auto-refresh-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #151515;
            border: 1px solid #2a2a2a;
            padding: 10px 15px;
            font-size: 0.8rem;
            color: #888;
            border-radius: 4px;
            z-index: 1000;
            transition: all 0.3s ease;
        }

        .auto-refresh-indicator.active {
            color: #44ff44;
            border-color: #2a4a2a;
        }

        .auto-refresh-indicator.checking {
            color: #ffaa00;
            border-color: #4a4a2a;
        }

        .settings-toggle {
            position: fixed;
            top: 70px;
            right: 20px;
            background: #151515;
            border: 1px solid #2a2a2a;
            padding: 8px 12px;
            font-size: 0.75rem;
            color: #888;
            border-radius: 4px;
            z-index: 1000;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .settings-toggle:hover {
            color: #e0e0e0;
            border-color: #4a4a4a;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: #151515;
            border: 1px solid #2a2a2a;
            padding: 20px;
            transition: border-color 0.2s ease;
        }
        
        .stat-card:hover {
            border-color: #4a4a4a;
        }
        
        .stat-card h3 {
            color: #e0e0e0;
            font-size: 2rem;
            margin-bottom: 5px;
            font-weight: 300;
        }
        
        .stat-card p {
            color: #888;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .pattern-card {
            background: #151515;
            border: 1px solid #2a2a2a;
            padding: 25px;
            margin-bottom: 20px;
        }
        
        .pattern-card h2 {
            color: #e0e0e0;
            margin-bottom: 20px;
            font-size: 1.1rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 300;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s ease;
        }

        .pattern-card h2:hover {
            color: #ffffff;
        }

        .pattern-card h2::after {
            content: '[ collapse ]';
            font-size: 0.75rem;
            font-weight: normal;
            color: #888;
            transition: all 0.2s ease;
        }

        .pattern-card h2.collapsed::after {
            content: '[ expand ]';
            transform: none;
        }

        .pattern-content {
            transition: max-height 0.3s ease;
            overflow: hidden;
        }

        .pattern-content.collapsed {
            max-height: 0;
        }
        
        .pattern-summary {
            background: #0a0a0a;
            border: 1px solid #2a2a2a;
            padding: 15px;
            margin-bottom: 15px;
            font-size: 0.9rem;
            line-height: 1.6;
        }
        
        .pattern-class-name {
            color: #e0e0e0;
            font-weight: 600;
        }
        
        .pattern-schedule {
            color: #888;
            margin-top: 5px;
        }
        
        .pattern-weekdays {
            color: #e0e0e0;
            text-transform: uppercase;
        }
        
        .pattern-dates {
            color: #666;
            font-size: 0.85rem;
        }
        
        .pattern-group {
            background: #0a0a0a;
            border: 1px solid #2a2a2a;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .pattern-group h3 {
            color: #e0e0e0;
            margin-bottom: 10px;
            font-size: 0.95rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
        }
        
        .event-list {
            list-style: none;
        }
        
        .event-list.collapsed {
            max-height: 200px;
            overflow: hidden;
        }
        
        .event-item {
            padding: 8px 0;
            border-bottom: 1px solid #2a2a2a;
            font-size: 0.85rem;
            color: #888;
        }
        
        .event-item:last-child {
            border-bottom: none;
        }
        
        .event-date {
            display: inline-block;
            background: #2a2a2a;
            color: #e0e0e0;
            padding: 2px 8px;
            font-size: 0.75rem;
            margin-right: 10px;
        }
        
        .badge {
            display: inline-block;
            padding: 2px 8px;
            font-size: 0.75rem;
            margin-right: 5px;
            margin-bottom: 5px;
            background: #2a2a2a;
            color: #888;
        }
        
        .badge-frequency {
            background: #1a1a1a;
            color: #e0e0e0;
            border: 1px solid #2a2a2a;
        }
        
        .badge-location {
            background: #0a0a0a;
            color: #888;
            border: 1px solid #2a2a2a;
        }
        
        .expand-button {
            background: none;
            border: 1px solid #2a2a2a;
            color: #888;
            padding: 4px 12px;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.75rem;
            margin-top: 10px;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .expand-button:hover {
            border-color: #4a4a4a;
            color: #e0e0e0;
        }

        .error-message {
            background: #1a0a0a;
            color: #ff4444;
            padding: 15px;
            border: 1px solid #441111;
            margin-top: 20px;
            display: none;
            font-size: 0.85rem;
        }
        
        .status-message {
            padding: 15px;
            margin-top: 20px;
            display: none;
            font-size: 0.85rem;
            border: 1px solid;
            transition: all 0.3s ease;
        }

        .day-break.short {
            color: #666;
            background: #0a0a0a;
            border: 1px dotted #1a2a1a;
            opacity: 0.8;
            font-size: 0.75rem;
        }

        .status-message.loading {
            background: #1a0a0a;
            color: #ffaa00;
            border-color: #443300;
        }

        .status-message.success {
            background: #0a0a0a;
            color: #44ff44;
            border-color: #114411;
        }

        .status-message.error {
            background: #1a0a0a;
            color: #ff4444;
            border-color: #441111;
        }

        .status-message.info {
            background: #0a0a1a;
            color: #4488ff;
            border-color: #111144;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
            font-size: 0.85rem;
        }

        .day-break {
            color: #888;
            font-size: 0.8rem;
            padding: 8px;
            margin: 5px 0;
            background: #1a1a0a;
            border: 1px dashed #2a4a2a;
            font-style: italic;
        }

        .break-time {
            font-weight: bold;
            color: #e0e0e0;
        }

        .break-type {
            color: #66aa66;
            text-transform: uppercase;
            font-size: 0.75rem;
        }

        .settings-section {
            background: #151515;
            border: 1px solid #2a2a2a;
            padding: 25px;
            margin-bottom: 30px;
            display: none;
        }

        .settings-section h2 {
            color: #e0e0e0;
            margin-bottom: 20px;
            font-size: 1.1rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 300;
        }

        .settings-group {
            margin-bottom: 20px;
        }

        .settings-group label {
            display: block;
            color: #e0e0e0;
            margin-bottom: 8px;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .keywords-input {
            width: 100%;
            padding: 12px;
            background: #0a0a0a;
            color: #e0e0e0;
            border: 1px solid #2a2a2a;
            font-family: inherit;
            font-size: 0.85rem;
            margin-bottom: 8px;
        }

        .keywords-input:focus {
            outline: none;
            border-color: #4a4a4a;
        }

        .keywords-help {
            color: #888;
            font-size: 0.8rem;
            font-style: italic;
        }

        .settings-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .settings-button {
            padding: 10px 20px;
            background: #0a0a0a;
            color: #e0e0e0;
            border: 1px solid #2a2a2a;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s ease;
        }

        .settings-button:hover {
            border-color: #4a4a4a;
            background: #1a1a1a;
        }

        .settings-button.primary {
            background: #2a2a2a;
            border-color: #4a4a4a;
        }

        .settings-button.primary:hover {
            background: #3a3a3a;
            border-color: #5a5a5a;
        }

        .current-keywords {
            background: #0a0a0a;
            border: 1px solid #2a2a2a;
            padding: 10px;
            margin-top: 10px;
            font-size: 0.8rem;
        }

        .keyword-tag {
            display: inline-block;
            background: #ff8800;
            color: #0a0a0a;
            padding: 2px 6px;
            margin: 2px;
            font-size: 0.75rem;
            font-weight: bold;
        }

        /* Mobile-friendly responsive design */
        @media (max-width: 768px) {
            body {
                padding: 10px;
                padding-bottom: 80px; /* Increased padding for mobile controls */
            }

            .header h1 {
                font-size: 1.3rem; /* Slightly smaller */
                margin-bottom: 8px;
                letter-spacing: 1px; /* Reduced letter spacing */
            }

            .header p {
                font-size: 0.75rem; /* Smaller subtitle */
            }

            .upload-section {
                padding: 15px 12px; /* Reduced padding */
                margin-bottom: 15px;
            }

            .next-week-section {
                padding: 12px;
                margin-bottom: 15px;
            }

            .pattern-card {
                padding: 12px; /* Reduced padding */
                margin-bottom: 15px;
            }

            /* Mobile control bar - always visible and persistent */
            .mobile-controls {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                display: flex !important; /* Force display on mobile */
                justify-content: space-between;
                align-items: center;
                background: #151515;
                border: 1px solid #2a2a2a;
                border-bottom: none;
                padding: 8px 12px;
                gap: 8px;
                z-index: 1000; /* Higher z-index */
                box-shadow: 0 -2px 10px rgba(0,0,0,0.5); /* Add shadow for better visibility */
            }

            /* Hide desktop positioning on mobile */
            .auto-refresh-indicator:not(#mobileAutoRefreshIndicator) {
                display: none !important;
            }

            .settings-toggle:not(#mobileSettingsToggle) {
                display: none !important;
            }

            /* Mobile auto-refresh indicator styling */
            #mobileAutoRefreshIndicator {
                position: static;
                background: transparent;
                border: none;
                padding: 0;
                font-size: 0.65rem; /* Smaller font */
                flex: 1;
                text-align: left;
                color: #888;
                min-width: 0; /* Allow shrinking */
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }

            #mobileAutoRefreshIndicator.active {
                color: #44ff44;
            }

            #mobileAutoRefreshIndicator.checking {
                color: #ffaa00;
            }

            /* Mobile settings toggle styling */
            #mobileSettingsToggle {
                position: static;
                background: #0a0a0a;
                border: 1px solid #2a2a2a;
                padding: 6px 8px; /* Smaller padding */
                font-size: 0.65rem; /* Smaller font */
                border-radius: 3px;
                flex-shrink: 0;
                color: #888;
                transition: all 0.3s ease;
            }

            #mobileSettingsToggle:hover {
                color: #e0e0e0;
                border-color: #4a4a4a;
            }

            /* Pattern card headers - fix overflow issues */
            .pattern-card h2 {
                font-size: 0.95rem; /* Smaller font */
                letter-spacing: 0.5px; /* Reduced letter spacing */
                line-height: 1.3;
                flex-wrap: wrap; /* Allow wrapping */
                gap: 5px;
            }

            .pattern-card h2::after {
                content: '[ ± ]'; /* Shorter collapse indicator */
                font-size: 0.7rem;
                font-weight: normal;
                color: #888;
                transition: all 0.2s ease;
                flex-shrink: 0; /* Prevent shrinking */
            }

            .pattern-card h2.collapsed::after {
                content: '[ + ]';
            }

            /* Make expand buttons smaller on mobile */
            .expand-button {
                padding: 2px 6px;
                font-size: 0.6rem; /* Smaller font */
                margin-top: 5px;
                letter-spacing: 0.5px; /* Reduced letter spacing */
            }

            /* Improve event readability on mobile */
            .day-event {
                font-size: 0.75rem; /* Smaller font */
                padding: 6px 8px;
                margin: 2px 0;
                line-height: 1.3;
            }

            .day-event.current {
                padding: 8px;
                margin: 3px 0;
            }

            .day-event.upcoming {
                padding: 7px 8px;
                margin: 2px 0;
            }

            .day-header {
                font-size: 0.85rem; /* Smaller font */
                flex-direction: column;
                align-items: flex-start;
                gap: 5px;
            }

            .day-date {
                font-size: 0.75rem; /* Smaller font */
            }

            /* Better spacing for URL input on mobile */
            .url-input-wrapper {
                flex-direction: column;
                gap: 8px;
            }

            .url-input {
                font-size: 0.8rem; /* Smaller font */
                padding: 10px; /* Reduced padding */
            }

            .fetch-button {
                width: 100%;
                padding: 10px;
                font-size: 0.8rem; /* Smaller font */
            }

            /* Improve pattern card readability */
            .pattern-group h3 {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
                font-size: 0.85rem; /* Smaller font */
            }

            .event-date {
                display: block;
                margin-bottom: 5px;
                margin-right: 0;
                font-size: 0.7rem; /* Smaller font */
            }

            .event-item {
                font-size: 0.75rem; /* Smaller font */
                padding: 6px 0; /* Reduced padding */
            }

            /* Smaller badges on mobile */
            .badge {
                font-size: 0.65rem; /* Smaller font */
                padding: 1px 6px; /* Smaller padding */
                margin: 1px;
            }

            /* Stats grid improvements */
            .stats-grid {
                grid-template-columns: repeat(2, 1fr); /* 2 columns instead of auto-fit */
                gap: 15px;
            }

            .stat-card {
                padding: 15px; /* Reduced padding */
            }

            .stat-card h3 {
                font-size: 1.5rem; /* Smaller font */
            }

            .stat-card p {
                font-size: 0.75rem; /* Smaller font */
            }

            /* Settings section mobile improvements */
            .settings-section h2 {
                font-size: 0.95rem; /* Smaller font */
            }

            .keywords-input {
                font-size: 0.8rem; /* Smaller font */
                padding: 10px; /* Reduced padding */
            }

            .settings-button {
                font-size: 0.75rem; /* Smaller font */
                padding: 8px 15px; /* Reduced padding */
            }

            /* Status and error messages */
            .status-message,
            .error-message {
                font-size: 0.75rem; /* Smaller font */
                padding: 12px; /* Reduced padding */
            }

            /* Divider styling */
            .divider {
                font-size: 0.7rem; /* Smaller font */
                margin: 15px 0; /* Reduced margin */
            }

            /* File input label */
            .file-input-label {
                font-size: 0.8rem; /* Smaller font */
                padding: 12px; /* Reduced padding */
            }
        }

        /* Extra small mobile devices */
        @media (max-width: 480px) {
            body {
                padding: 6px;
                padding-bottom: 85px; /* More padding for smaller screens */
            }

            .header h1 {
                font-size: 1.1rem; /* Even smaller */
                letter-spacing: 0.5px;
            }

            .header p {
                font-size: 0.7rem;
            }

            .upload-section,
            .next-week-section,
            .pattern-card {
                padding: 10px;
            }

            .mobile-controls {
                padding: 6px 8px;
                font-size: 0.6rem;
            }

            #mobileAutoRefreshIndicator {
                font-size: 0.6rem;
            }

            #mobileSettingsToggle {
                font-size: 0.6rem;
                padding: 5px 6px;
            }

            /* Make expand buttons even smaller on very small screens */
            .expand-button {
                padding: 1px 4px;
                font-size: 0.55rem;
            }

            .day-events {
                margin-left: 8px; /* Reduced margin */
            }

            .pattern-summary {
                padding: 8px; /* Reduced padding */
                font-size: 0.75rem; /* Smaller font */
            }

            .pattern-card h2 {
                font-size: 0.85rem;
            }

            .pattern-card h2::after {
                font-size: 0.65rem;
            }

            /* Very small stats grid */
            .stats-grid {
                gap: 10px;
            }

            .stat-card {
                padding: 12px;
            }

            .stat-card h3 {
                font-size: 1.3rem;
            }

            .stat-card p {
                font-size: 0.7rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>what's my rooster?</h1>
            <p>calendar pattern analyzer</p>
            <div class="current-date" id="currentDate"></div>
        </div>
        
        <div class="upload-section">
            <!-- Mobile controls bar for smaller screens -->
            <div class="mobile-controls" style="display: none;">
                <div class="auto-refresh-indicator" id="mobileAutoRefreshIndicator">
                    ◐ auto-refresh: off
                </div>
                <div class="settings-toggle" id="mobileSettingsToggle">
                    [ settings ]
                </div>
            </div>

            <div class="input-group">
                <div class="file-input-wrapper">
                    <input type="file" id="fileInput" accept=".ics,.ical,.ifb,.icalendar">
                    <label for="fileInput" class="file-input-label">
                        [ upload .ics ]
                    </label>
                </div>
            </div>
            
            <div class="divider">— OR —</div>

            <div class="input-group">
                <div class="url-input-wrapper">
                    <input type="text" class="url-input" id="urlInput" placeholder="enter calendar url">
                    <button class="fetch-button" onclick="fetchFromURL()">[ fetch ]</button>
                </div>
            </div>
            
            <div class="error-message" id="errorMessage"></div>
            <div class="status-message" id="statusMessage"></div>
        </div>
        
        <div class="results-section" id="resultsSection">
            <div class="next-week-section" id="nextWeekSection"></div>
            <div class="stats-grid" id="statsGrid"></div>
            <div id="patternsContainer"></div>
        </div>

        <div class="settings-section" id="settingsSection">
            <h2>Settings</h2>
            <div class="settings-group">
                <label for="keywordsInput">Manage Highlight Keywords</label>
                <input type="text" id="keywordsInput" class="keywords-input" placeholder="Enter keywords separated by commas">
                <div class="keywords-help">Tip: Use keywords like "exam, test, quiz" to highlight important events.</div>
            </div>
            <div class="settings-buttons">
                <button class="settings-button" id="saveKeywordsButton">[ Save Keywords ]</button>
                <button class="settings-button" id="resetKeywordsButton">[ Reset to Default ]</button>
            </div>
        </div>
    </div>

    <!-- Auto-refresh indicator -->
    <div class="auto-refresh-indicator" id="autoRefreshIndicator">
        ◐ auto-refresh: off
    </div>

    <!-- Settings toggle -->
    <div class="settings-toggle" id="settingsToggle">
        [ settings ]
    </div>

    <script>
        // Global variables for auto-refresh functionality
        let autoRefreshInterval = null;
        let lastCalendarHash = '';
        let currentPatterns = null;
        let timeUpdateInterval = null;
        let showNoChangesNotification = false; // Track whether to show "no changes" notifications

        // Display current date
        const today = new Date();
        document.getElementById('currentDate').textContent = `today: ${today.toLocaleDateString('en-GB', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })}`;

        // Simple ICS parser
        function parseICS(icsContent) {
            const events = [];
            const lines = icsContent.split(/\r?\n/);
            let currentEvent = null;

            for (let i = 0; i < lines.length; i++) {
                let line = lines[i];
                
                // Handle line folding (lines that start with space or tab)
                while (i + 1 < lines.length && (lines[i + 1].startsWith(' ') || lines[i + 1].startsWith('\t'))) {
                    line += lines[i + 1].substring(1);
                    i++;
                }
                
                if (line === 'BEGIN:VEVENT') {
                    currentEvent = {};
                } else if (line === 'END:VEVENT' && currentEvent) {
                    events.push(currentEvent);
                    currentEvent = null;
                } else if (currentEvent) {
                    const colonIndex = line.indexOf(':');
                    if (colonIndex > -1) {
                        const key = line.substring(0, colonIndex).split(';')[0];
                        const value = line.substring(colonIndex + 1);

                        switch(key) {
                            case 'SUMMARY':
                                currentEvent.summary = value;
                                break;
                            case 'DTSTART':
                                currentEvent.start = parseDate(value);
                                break;
                            case 'DTEND':
                                currentEvent.end = parseDate(value);
                                break;
                            case 'LOCATION':
                                currentEvent.location = value;
                                break;
                            case 'DESCRIPTION':
                                currentEvent.description = value;
                                break;
                            case 'RRULE':
                                currentEvent.rrule = value;
                                break;
                        }
                    }
                }
            }
            
            return events;
        }
        
        function parseDate(dateStr) {
            // Handle both datetime and date formats
            if (dateStr.length === 8) {
                // Date only format: YYYYMMDD
                const year = dateStr.substring(0, 4);
                const month = dateStr.substring(4, 6);
                const day = dateStr.substring(6, 8);
                return new Date(`${year}-${month}-${day}`);
            } else if (dateStr.includes('T')) {
                // DateTime format: YYYYMMDDTHHMMSS or with timezone
                const datePart = dateStr.substring(0, 8);
                const timePart = dateStr.substring(9, 15);
                
                const year = datePart.substring(0, 4);
                const month = datePart.substring(4, 6);
                const day = datePart.substring(6, 8);
                const hour = timePart.substring(0, 2);
                const minute = timePart.substring(2, 4);
                const second = timePart.substring(4, 6);
                
                return new Date(`${year}-${month}-${day}T${hour}:${minute}:${second}`);
            }
            return new Date(dateStr);
        }

        function analyzePatterns(events) {
            const patterns = {
                byTimeSlot: {},
                byDayTime: {},
                byName: {},
                byLocation: {},
                recurring: [],
                weeklyPatterns: {},
                smartPatterns: [], // New: actual recurring patterns
                stats: {
                    totalEvents: events.length,
                    uniqueNames: new Set(),
                    uniqueLocations: new Set(),
                    dateRange: { start: null, end: null }
                }
            };

            events.forEach(event => {
                if (!event.start) return;

                // Update stats
                patterns.stats.uniqueNames.add(event.summary || 'Untitled');
                if (event.location) patterns.stats.uniqueLocations.add(event.location);

                if (!patterns.stats.dateRange.start || event.start < patterns.stats.dateRange.start) {
                    patterns.stats.dateRange.start = event.start;
                }
                if (!patterns.stats.dateRange.end || event.start > patterns.stats.dateRange.end) {
                    patterns.stats.dateRange.end = event.start;
                }

                // Analyze by day and time
                const day = event.start.toLocaleDateString('en-GB', { weekday: 'long' });
                const time = event.start.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit', hour12: false });
                const dayTimeKey = `${day} ${time}`;

                if (!patterns.byDayTime[dayTimeKey]) {
                    patterns.byDayTime[dayTimeKey] = [];
                }
                patterns.byDayTime[dayTimeKey].push(event);

                // Analyze by time slot only
                if (!patterns.byTimeSlot[time]) {
                    patterns.byTimeSlot[time] = [];
                }
                patterns.byTimeSlot[time].push(event);

                // Analyze by exact name
                const className = event.summary || 'Untitled';
                if (!patterns.byName[className]) {
                    patterns.byName[className] = [];
                }
                patterns.byName[className].push(event);

                // Keep the old weekly patterns for compatibility
                if (!patterns.weeklyPatterns[className]) {
                    patterns.weeklyPatterns[className] = {
                        times: {},
                        events: []
                    };
                }
                patterns.weeklyPatterns[className].events.push(event);
                const weekdayTime = `${day} @ ${time}`;
                if (!patterns.weeklyPatterns[className].times[weekdayTime]) {
                    patterns.weeklyPatterns[className].times[weekdayTime] = 0;
                }
                patterns.weeklyPatterns[className].times[weekdayTime]++;

                // Analyze by location
                if (event.location) {
                    if (!patterns.byLocation[event.location]) {
                        patterns.byLocation[event.location] = [];
                    }
                    patterns.byLocation[event.location].push(event);
                }

                // Check for RRULE (recurring events)
                if (event.rrule) {
                    patterns.recurring.push(event);
                }
            });

            // NEW: Analyze smart patterns - actual weekly recurring patterns
            patterns.smartPatterns = analyzeSmartWeeklyPatterns(events);

            return patterns;
        }

        // NEW: Smart weekly pattern analysis
        function analyzeSmartWeeklyPatterns(events) {
            const smartPatterns = [];

            // Filter events to next month only
            const today = new Date();
            const nextMonth = new Date(today);
            nextMonth.setMonth(today.getMonth() + 1);

            const nextMonthEvents = events.filter(event => {
                if (!event.start) return false;
                return event.start >= today && event.start <= nextMonth;
            });

            // Group events by name and location (more specific grouping)
            const eventGroups = {};
            nextMonthEvents.forEach(event => {
                if (!event.start) return;

                const key = `${event.summary || 'Untitled'}|${event.location || 'No Location'}`;
                if (!eventGroups[key]) {
                    eventGroups[key] = [];
                }
                eventGroups[key].push(event);
            });

            // Analyze each group for actual recurring patterns
            Object.entries(eventGroups).forEach(([key, groupEvents]) => {
                const [className, location] = key.split('|');

                if (groupEvents.length < 2) return; // Need at least 2 events for next month view

                // Sort events by date
                groupEvents.sort((a, b) => a.start - b.start);

                // Detect weekly recurring patterns
                const weeklyPatterns = detectWeeklyRecurrence(groupEvents, className, location);
                smartPatterns.push(...weeklyPatterns);
            });

            // Sort by pattern strength (consistency and frequency)
            smartPatterns.sort((a, b) => {
                const scoreA = a.consistency * a.occurrences;
                const scoreB = b.consistency * b.occurrences;
                return scoreB - scoreA;
            });

            return smartPatterns;
        }

        // NEW: Detect actual weekly recurring patterns
        function detectWeeklyRecurrence(events, className, location) {
            const patterns = [];

            // Group by day of week and time
            const dayTimeGroups = {};
            events.forEach(event => {
                const dayOfWeek = event.start.getDay(); // 0 = Sunday, 1 = Monday, etc.
                const timeKey = event.start.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit', hour12: false });
                const key = `${dayOfWeek}-${timeKey}`;

                if (!dayTimeGroups[key]) {
                    dayTimeGroups[key] = [];
                }
                dayTimeGroups[key].push(event);
            });

            // Analyze each day-time combination for weekly recurrence
            Object.entries(dayTimeGroups).forEach(([key, dayTimeEvents]) => {
                if (dayTimeEvents.length < 3) return; // Need at least 3 occurrences

                const [dayOfWeek, timeKey] = key.split('-');
                const dayName = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][parseInt(dayOfWeek)];

                // Sort by date
                dayTimeEvents.sort((a, b) => a.start - b.start);

                // Check for weekly consistency
                const weeklyConsistency = calculateWeeklyConsistency(dayTimeEvents);

                if (weeklyConsistency.isWeeklyPattern) {
                    patterns.push({
                        className: className,
                        location: location === 'No Location' ? null : location,
                        dayOfWeek: dayName,
                        time: timeKey,
                        occurrences: dayTimeEvents.length,
                        consistency: weeklyConsistency.consistency,
                        frequency: weeklyConsistency.frequency,
                        startDate: dayTimeEvents[0].start,
                        endDate: dayTimeEvents[dayTimeEvents.length - 1].start,
                        events: dayTimeEvents,
                        pattern: weeklyConsistency.pattern,
                        gaps: weeklyConsistency.gaps
                    });
                }
            });

            return patterns;
        }

        // NEW: Calculate if events follow a weekly pattern
        function calculateWeeklyConsistency(events) {
            if (events.length < 3) {
                return { isWeeklyPattern: false, consistency: 0 };
            }

            // Calculate week differences between consecutive events
            const weekDiffs = [];
            for (let i = 1; i < events.length; i++) {
                const daysDiff = (events[i].start - events[i-1].start) / (1000 * 60 * 60 * 24);
                const weeksDiff = Math.round(daysDiff / 7);
                weekDiffs.push(weeksDiff);
            }

            // Count frequency of each week difference
            const diffCounts = {};
            weekDiffs.forEach(diff => {
                diffCounts[diff] = (diffCounts[diff] || 0) + 1;
            });

            // Find the most common pattern
            const sortedDiffs = Object.entries(diffCounts).sort((a, b) => b[1] - a[1]);
            const mostCommonDiff = parseInt(sortedDiffs[0][0]);
            const mostCommonCount = sortedDiffs[0][1];

            // Calculate consistency percentage
            const consistency = mostCommonCount / weekDiffs.length;

            // Determine if it's a weekly pattern
            const isWeeklyPattern = mostCommonDiff >= 1 && consistency >= 0.6; // At least 60% consistent

            // Calculate actual frequency
            const totalWeeks = Math.ceil((events[events.length - 1].start - events[0].start) / (1000 * 60 * 60 * 24 * 7));
            const frequency = events.length / Math.max(totalWeeks, 1);

            // Detect gaps (weeks where the event should have occurred but didn't)
            const gaps = [];
            if (isWeeklyPattern && mostCommonDiff === 1) {
                // For weekly events, check for missing weeks
                for (let i = 1; i < events.length; i++) {
                    const expectedDate = new Date(events[i-1].start);
                    expectedDate.setDate(expectedDate.getDate() + 7);

                    const actualDate = events[i].start;
                    const daysDiff = (actualDate - expectedDate) / (1000 * 60 * 60 * 24);

                    if (daysDiff > 10) { // More than 10 days difference indicates gaps
                        const weeksGap = Math.round(daysDiff / 7);
                        gaps.push({ after: events[i-1].start, weeks: weeksGap - 1 });
                    }
                }
            }

            let pattern = 'irregular';
            if (isWeeklyPattern) {
                if (mostCommonDiff === 1 && consistency >= 0.9) {
                    pattern = 'weekly';
                } else if (mostCommonDiff === 2 && consistency >= 0.8) {
                    pattern = 'bi-weekly';
                } else if (mostCommonDiff === 1 && consistency >= 0.6) {
                    pattern = 'mostly weekly';
                } else {
                    pattern = `every ${mostCommonDiff} weeks`;
                }
            }

            return {
                isWeeklyPattern,
                consistency,
                frequency,
                pattern,
                gaps,
                mostCommonInterval: mostCommonDiff
            };
        }

        function getNextWeekEvents(events) {
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            const nextWeek = new Date(today);
            nextWeek.setDate(today.getDate() + 7);

            const weekEvents = events.filter(event => {
                if (!event.start) return false;
                const eventDate = new Date(event.start);
                eventDate.setHours(0, 0, 0, 0);
                return eventDate >= today && eventDate < nextWeek;
            }).sort((a, b) => a.start - b.start);

            // Group by day
            const byDay = {};
            weekEvents.forEach(event => {
                const dayKey = event.start.toLocaleDateString('en-GB', { weekday: 'long', month: 'short', day: 'numeric' });
                if (!byDay[dayKey]) {
                    byDay[dayKey] = [];
                }
                byDay[dayKey].push(event);
            });

            return byDay;
        }

        function formatWeeklyPattern(className, pattern) {
            const times = Object.entries(pattern.times)
                .filter(([time, count]) => count >= 2) // Only show if it happened at least twice
                .sort((a, b) => {
                    const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
                    const dayA = days.findIndex(d => a[0].toLowerCase().includes(d));
                    const dayB = days.findIndex(d => b[0].toLowerCase().includes(d));
                    return dayA - dayB;
                });

            if (times.length === 0) return null;

            // Get date range
            const dates = pattern.events.map(e => e.start).sort((a, b) => a - b);
            const startDate = dates[0];
            const endDate = dates[dates.length - 1];

            // Format weekly occurrences
            const weekdays = times.map(([time]) => {
                const parts = time.split(' @ ');
                return `${parts[0].toUpperCase().slice(0, 3)} @ ${parts[1]}`;
            }).join(', ');

            // Determine frequency
            const weekSpan = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24 * 7));
            const frequency = pattern.events.length / Math.max(weekSpan, 1);

            let frequencyText = 'occurs ';
            if (frequency >= 0.8) {
                frequencyText += 'weekly';
            } else if (frequency >= 0.4) {
                frequencyText += 'bi-weekly';
            } else {
                frequencyText += 'occasionally';
            }

            return {
                summary: `${className} ${frequencyText} ${weekdays} until ${endDate.toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' })}`,
                className,
                weekdays,
                startDate,
                endDate,
                occurrences: pattern.events.length
            };
        }

        function analyzeBreakSlots(dayEvents) {
            if (!dayEvents || dayEvents.length === 0) return [];

            const breaks = [];
            const sortedEvents = dayEvents.sort((a, b) => a.start - b.start);

            // Check for break before first event (if event starts after 10:00)
            const firstEvent = sortedEvents[0];
            const firstEventTime = firstEvent.start.getHours() * 60 + firstEvent.start.getMinutes();
            if (firstEventTime > 10 * 60) { // After 10:00 AM
                const breakStart = Math.max(9 * 60, firstEventTime - 90); // Start at 9 AM or 1.5h before
                const breakEnd = firstEventTime - 15; // 15 min before first event
                const duration = Math.max(0, breakEnd - breakStart); // Calculate duration in minutes

                if (duration >= 10) { // Show breaks of 10+ minutes
                    breaks.push({
                        start: Math.floor(breakStart / 60),
                        startMin: breakStart % 60,
                        end: Math.floor(breakEnd / 60),
                        endMin: breakEnd % 60,
                        type: 'morning break',
                        duration: Math.floor(duration),
                        isShort: duration < 30
                    });
                }
            }

            // Check gaps between events (lunch opportunities)
            for (let i = 0; i < sortedEvents.length - 1; i++) {
                const currentEnd = sortedEvents[i].end || sortedEvents[i].start;
                const nextStart = sortedEvents[i + 1].start;

                const gapMinutes = (nextStart - currentEnd) / (1000 * 60);

                if (gapMinutes >= 15) { // Show breaks of 15+ minutes
                    const breakStartTime = new Date(currentEnd.getTime() + 10 * 60 * 1000); // 10 min after previous event
                    const breakEndTime = new Date(nextStart.getTime() - 10 * 60 * 1000); // 10 min before next event

                    const breakDuration = (breakEndTime - breakStartTime) / (1000 * 60);
                    if (breakDuration >= 10) {
                        const startHour = breakStartTime.getHours();
                        const startMin = breakStartTime.getMinutes();
                        const endHour = breakEndTime.getHours();
                        const endMin = breakEndTime.getMinutes();

                        let breakType = 'break';
                        if (startHour >= 11 && startHour <= 14 && breakDuration >= 30) {
                            breakType = 'lunch';
                        } else if (startHour >= 15 && startHour <= 17) {
                            breakType = 'afternoon break';
                        }

                        breaks.push({
                            start: startHour,
                            startMin: startMin,
                            end: endHour,
                            endMin: endMin,
                            type: breakType,
                            duration: Math.floor(breakDuration),
                            isShort: breakDuration < 30
                        });
                    }
                }
            }

            // Check for break after last event (if event ends before 18:00)
            const lastEvent = sortedEvents[sortedEvents.length - 1];
            const lastEventEnd = lastEvent.end || lastEvent.start;
            const lastEventTime = lastEventEnd.getHours() * 60 + lastEventEnd.getMinutes();
            if (lastEventTime < 18 * 60) { // Before 6:00 PM
                const breakStart = lastEventTime + 10; // 10 min after last event
                const breakEnd = 18 * 60; // Until 6:00 PM
                const duration = breakEnd - breakStart;

                if (duration >= 10) { // Show breaks of 10+ minutes
                    breaks.push({
                        start: Math.floor(breakStart / 60),
                        startMin: breakStart % 60,
                        end: 18,
                        endMin: 0,
                        type: 'evening break',
                        duration: Math.floor(duration),
                        isShort: duration < 30
                    });
                }
            }

            return breaks;
        }
        function getCurrentEventStatus(dayEvents) {
            if (!dayEvents || dayEvents.length === 0) return null;

            const now = new Date();
            const nowTime = now.getHours() * 60 + now.getMinutes();

            for (let i = 0; i < dayEvents.length; i++) {
                const event = dayEvents[i];
                const eventStart = event.start.getHours() * 60 + event.start.getMinutes();
                const eventEnd = event.end ? (event.end.getHours() * 60 + event.end.getMinutes()) : (eventStart + 60);

                if (nowTime >= eventStart && nowTime <= eventEnd) {
                    return { event, status: 'current', indicator: '>' };
                }

                if (nowTime < eventStart) {
                    const timeDiff = eventStart - nowTime;
                    if (timeDiff <= 30) { // Next event within 30 minutes
                        return { event, status: 'upcoming', indicator: '>>', minutesUntil: timeDiff };
                    }
                    return { event, status: 'next', indicator: '>' };
                }
            }

            return null;
        }

        function analyzeDayPatterns(events) {
            const patterns = {
                timeSlots: {},
                breaks: [],
                currentEvent: null,
                upcomingEvent: null,
                nextEvent: null
            };

            events.forEach(event => {
                if (!event.start) return;

                // Analyze time slots
                const timeSlot = event.start.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit', hour12: false });
                if (!patterns.timeSlots[timeSlot]) {
                    patterns.timeSlots[timeSlot] = [];
                }
                patterns.timeSlots[timeSlot].push(event);
            });

            // Analyze breaks and current status
            const now = new Date();
            const currentHour = now.getHours();
            const currentMin = now.getMinutes();
            const nowTime = currentHour * 60 + currentMin;

            const sortedEvents = events.sort((a, b) => a.start - b.start);
            patterns.breaks = analyzeBreakSlots(sortedEvents);

            // Determine current, upcoming, and next events
            if (sortedEvents.length > 0) {
                const firstEvent = sortedEvents[0];
                const lastEvent = sortedEvents[sortedEvents.length - 1];

                // Current event (ongoing)
                if (now >= firstEvent.start && now <= (firstEvent.end || firstEvent.start)) {
                    patterns.currentEvent = firstEvent;
                }

                // Upcoming event (next in the future)
                for (let i = 0; i < sortedEvents.length; i++) {
                    const event = sortedEvents[i];
                    const eventStart = event.start.getTime();

                    if (eventStart > now.getTime()) {
                        patterns.upcomingEvent = event;
                        break;
                    }
                }

                // Next event (next in the schedule, could be current or upcoming)
                if (patterns.currentEvent) {
                    patterns.nextEvent = patterns.currentEvent;
                } else if (patterns.upcomingEvent) {
                    patterns.nextEvent = patterns.upcomingEvent;
                }
            }

            return patterns;
        }

        function formatEventTime(event) {
            if (!event.start) return '';
            const options = { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false };
            return event.start.toLocaleTimeString('en-GB', options);
        }

        function formatEventDate(event) {
            if (!event.start) return '';
            return event.start.toLocaleDateString('en-GB', { weekday: 'short', month: 'short', day: 'numeric' });
        }

        function displayDailyOverview(events) {
            const container = document.getElementById('nextWeekSection');
            container.innerHTML = '';

            if (!events || events.length === 0) {
                container.innerHTML = '<p class="loading">no events found for the next 7 days.</p>';
                return;
            }

            // Analyze patterns for the day
            const dayPatterns = analyzeDayPatterns(events);

            // Display current, upcoming, and next events
            const currentStatus = dayPatterns.currentEvent ? `current: ${dayPatterns.currentEvent.summary}` : '';
            const upcomingStatus = dayPatterns.upcomingEvent ? `upcoming: ${dayPatterns.upcomingEvent.summary}` : '';
            const nextStatus = dayPatterns.nextEvent ? `next: ${dayPatterns.nextEvent.summary}` : '';

            const statusHTML = `
                <div class="day-status">
                    ${currentStatus ? `<div class="status-item">${currentStatus}</div>` : ''}
                    ${upcomingStatus ? `<div class="status-item">${upcomingStatus}</div>` : ''}
                    ${nextStatus ? `<div class="status-item">${nextStatus}</div>` : ''}
                </div>
            `;

            container.innerHTML += statusHTML;

            // Display time slots
            const timeSlots = Object.entries(dayPatterns.timeSlots).sort((a, b) => a[0].localeCompare(b[0]));
            timeSlots.forEach(([time, events]) => {
                const timeLabel = document.createElement('div');
                timeLabel.className = 'time-slot';
                timeLabel.innerHTML = `<strong>${time}</strong>`;
                container.appendChild(timeLabel);

                events.forEach(event => {
                    const eventDiv = document.createElement('div');
                    eventDiv.className = 'day-event';
                    eventDiv.innerHTML = `
                        <span class="event-time">${formatEventTime(event)}</span>
                        ${event.summary || 'Untitled'}
                        ${event.location ? ` @ ${event.location}` : ''}
                    `;
                    container.appendChild(eventDiv);
                });
            });

            // Display breaks
            dayPatterns.breaks.forEach(b => {
                const breakDiv = document.createElement('div');
                breakDiv.className = 'day-break';
                breakDiv.innerHTML = `${b.type} (${b.start}:${b.startMin} - ${b.end}:${b.endMin})`;
                container.appendChild(breakDiv);
            });
        }

        function displayResults(patterns) {
            const resultsSection = document.getElementById('resultsSection');
            const statsGrid = document.getElementById('statsGrid');
            const patternsContainer = document.getElementById('patternsContainer');
            const nextWeekSection = document.getElementById('nextWeekSection');

            // Clear previous results
            statsGrid.innerHTML = '';
            patternsContainer.innerHTML = '';
            nextWeekSection.innerHTML = '';

            // Display next week overview with enhanced features
            const allEvents = Object.values(patterns.byName).flat();
            const nextWeek = getNextWeekEvents(allEvents);
            const now = new Date();
            const currentTime = now.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit', hour12: false });

            if (Object.keys(nextWeek).length > 0) {
                const nextWeekHTML = Object.entries(nextWeek).map(([day, events]) => {
                    // Check if this is today
                    const dayDate = new Date(events[0].start);
                    dayDate.setHours(0, 0, 0, 0);
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    const isToday = dayDate.getTime() === today.getTime();

                    // Get current event status for today
                    let currentEventStatus = null;
                    if (isToday) {
                        currentEventStatus = getCurrentEventStatus(events);
                    }

                    // Analyze break opportunities for this day
                    const dayBreaks = analyzeBreakSlots(events);

                    return `
                        <div class="day-schedule ${isToday ? 'today' : ''}">
                            <div class="day-header ${isToday ? 'today' : ''}">
                                <span>${day} ${isToday ? '<span class="today-indicator">TODAY</span>' : ''}</span>
                                <div class="day-date">
                                    <span>[${events.length} events]</span>
                                    ${isToday ? `<span class="current-time">${currentTime}</span>` : ''}
                                </div>
                            </div>
                            <div class="day-events">
    ${events.map(event => {
                        let eventClass = 'day-event';
                        let indicator = '';

                        // Check for exam events and add exam class
                        if (isExamEvent(event)) {
                            eventClass += ' exam';
                        }

                        if (isToday && currentEventStatus) {
                            if (currentEventStatus.event === event) {
                                eventClass += ` ${currentEventStatus.status}`;
                                indicator = `<span class="event-indicator">${currentEventStatus.indicator}</span>`;

                                if( currentEventStatus.minutesUntil) {
                                    indicator += ` <span style="font-size: 0.7rem; color: #ffaa00;">(in ${currentEventStatus.minutesUntil}min)</span>`;
                                }
                            }
                        }

                        return `
            <div class="${eventClass}">
                ${indicator}
                <span class="event-time">${event.start.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit', hour12: false })}${event.end ? ' - ' + event.end.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit', hour12: false }) : ''}</span>
                ${event.summary || 'Untitled'}
                ${event.location ? ` @ ${event.location}` : ''}
            </div>
        `;
                    }).join('')}

    ${dayBreaks.map(b => {
                        const startTime = `${b.start}:${b.startMin.toString().padStart(2, '0')}`;
                        const endTime = `${b.end}:${b.endMin.toString().padStart(2, '0')}`;
                        return `
            <div class="day-break${b.isShort ? ' short' : ''}">
                <span class="break-time">${startTime} - ${endTime}</span>
                <span class="break-type">${b.type}</span>
                (${b.duration} min)
            </div>
        `;
                    }).join('')}
</div>
                        </div>
                    `;
                }).join('');

                nextWeekSection.innerHTML = `
                    <h2>// next 7 days</h2>
                    ${nextWeekHTML}
                `;
            }

            // Display stats
            const stats = patterns.stats;
            statsGrid.innerHTML = `
                <div class="stat-card">
                    <h3>${stats.totalEvents}</h3>
                    <p>total events</p>
                </div>
                <div class="stat-card">
                    <h3>${stats.uniqueNames.size}</h3>
                    <p>unique classes</p>
                </div>
                <div class="stat-card">
                    <h3>${stats.uniqueLocations.size}</h3>
                    <p>locations</p>
                </div>
                <div class="stat-card">
                    <h3>${Object.keys(patterns.byDayTime).length}</h3>
                    <p>time patterns</p>
                </div>
            `;

            // Display smart recurring patterns with grouping and collapsible functionality
            if (patterns.smartPatterns.length > 0) {
                // Group patterns by class name
                const groupedPatterns = {};
                patterns.smartPatterns.forEach(pattern => {
                    if (!groupedPatterns[pattern.className]) {
                        groupedPatterns[pattern.className] = [];
                    }
                    groupedPatterns[pattern.className].push(pattern);
                });

                const today = new Date();
                const nextMonth = new Date(today);
                nextMonth.setMonth(today.getMonth() + 1);

                const smartPatternsHTML = `
                    <div class="pattern-card">
                        <h2 onclick="togglePatternSection('smartPatterns')">// recurring patterns (next month)</h2>
                        <div class="pattern-content" id="smartPatterns">
                            ${Object.entries(groupedPatterns).map(([className, classPatterns]) => `
                                <div class="pattern-summary">
                                    <div class="pattern-class-name">${className}</div>
                                    ${classPatterns.map(pattern => {
                                        const consistencyPercent = Math.round(pattern.consistency * 100);
                                        const gapsText = pattern.gaps.length > 0 ? ` (${pattern.gaps.length} gaps)` : '';

                                        return `
                                            <div class="pattern-schedule">
                                                <span class="pattern-weekdays">${pattern.dayOfWeek.toUpperCase().slice(0, 3)} @ ${pattern.time}</span>
                                                - ${pattern.pattern} (${consistencyPercent}% consistent)${gapsText}
                                                ${pattern.location ? ` @ ${pattern.location}` : ''}
                                                <div class="pattern-dates">
                                                    ${pattern.startDate.toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' })}
                                                    →
                                                    ${pattern.endDate.toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' })}
                                                    [${pattern.occurrences}x]
                                                </div>
                                            </div>
                                        `;
                                    }).join('')}
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
                patternsContainer.innerHTML += smartPatternsHTML;
            }

            // Display recurring patterns (by day and time) with collapsible functionality
            const recurringPatterns = Object.entries(patterns.byDayTime)
                .filter(([key, events]) => events.length > 1)
                .sort((a, b) => b[1].length - a[1].length);

            if (recurringPatterns.length > 0) {
                const recurringHTML = `
                    <div class="pattern-card">
                        <h2 onclick="togglePatternSection('recurringSlots')" class="collapsed">// recurring time slots</h2>
                        <div class="pattern-content collapsed" id="recurringSlots" style="max-height: 0px;">
                            ${recurringPatterns.map(([dayTime, events], index) => {
                                const groupId = `recurring-${index}`;
                                const showExpand = events.length > 5;
                                return `
                                <div class="pattern-group">
                                    <h3>${dayTime} <span class="badge badge-frequency">[${events.length}x]</span></h3>
                                    <ul class="event-list ${showExpand ? 'collapsed' : ''}" id="${groupId}">
                                        ${events.map(event => `
                                            <li class="event-item">
                                                <span class="event-date">${event.start.toLocaleDateString('en-GB')}</span>
                                                ${event.summary || 'Untitled'}
                                                ${event.location ? `<span class="badge badge-location">${event.location}</span>` : ''}
                                            </li>
                                        `).join('')}
                                    </ul>
                                    ${showExpand ? `<button class="expand-button" onclick="toggleExpand('${groupId}', this)">[ expand ]</button>` : ''}
                                </div>
                            `;
                            }).join('')}
                        </div>
                    </div>
                `;
                patternsContainer.innerHTML += recurringHTML;
            }

            // Show results section
            resultsSection.style.display = 'block';
        }

        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = `[error] ${message}`;
            errorDiv.style.display = 'block';
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 5000);
        }

        // Cookie handling functions - FIXED
        function setCookie(name, value, days) {
            let expires = "";
            if (days) {
                const date = new Date();
                date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                expires = "; expires=" + date.toUTCString();
            }
            document.cookie = name + "=" + (value || "") + expires + "; path=/; SameSite=Lax";
        }

        function getCookie(name) {
            const nameEQ = name + "=";
            const ca = document.cookie.split(';');
            for (let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) === ' ') c = c.substring(1, c.length);
                if (c.indexOf(nameEQ) === 0) return decodeURIComponent(c.substring(nameEQ.length, c.length));
            }
            return null;
        }

        function deleteCookie(name) {
            document.cookie = name + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
        }

        // Status message handling
        function showStatus(message, type, isAutoLoad = false) {
            const statusDiv = document.getElementById('statusMessage');
            statusDiv.className = `status-message ${type}`;
            statusDiv.style.display = 'block';

            if (isAutoLoad && type === 'success') {
                statusDiv.textContent = `auto-loaded from saved url: ${message}`;
            } else {
                statusDiv.textContent = message;
            }

            setTimeout(() => {
                statusDiv.style.display = 'none';
            }, 5000);
        }

        // URL fetch handler
        async function fetchFromURL(isAutoLoad = false) {
            const urlInput = document.getElementById('urlInput');
            let url = urlInput.value.trim();

            if (!url) {
                showError('enter the link first!');
                return;
            }

            // Convert webcal:// to https://
            if (url.startsWith('webcal://')) {
                url = url.replace('webcal://', 'https://');
                urlInput.value = url; // Update the input to show the converted URL
            }

            // Show loading status
            if (isAutoLoad) {
                showStatus('auto-loading saved calendar...', 'info');
            } else {
                showStatus('fetching calendar...', 'loading');
            }

            try {
                // Try to fetch through a CORS proxy
                const proxyUrl = `https://corsproxy.io/?url=${encodeURIComponent(url)}`;
                const response = await fetch(proxyUrl);

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const content = await response.text();

                // Process the calendar content
                processICSContent(content);

                // Save URL to cookie (only if it's a manual fetch, not auto-load)
                if (!isAutoLoad) {
                    setCookie('calendarURL', url, 365); // Save for 30 days
                }

                // Show success message
                const truncatedUrl = url.length > 50 ? url.substring(0, 50) + '...' : url;
                showStatus(`calendar loaded successfully! (${truncatedUrl})`, 'success', isAutoLoad);

            } catch (error) {
                showStatus('✗ could not fetch calendar. try uploading an .ics file instead', 'error');
                console.error('Fetch error:', error);
            }
        }

        // File input handler
        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            if (!file.name.match(/\.(ics|ical|ifb|icalendar)$/i)) {
                showError('please upload a valid ics file.');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                processICSContent(e.target.result);
            };

            reader.readAsText(file);
        });

        // Auto-refresh and time update functionality
        function startAutoRefresh() {
            const indicator = document.getElementById('autoRefreshIndicator');
            indicator.className = 'auto-refresh-indicator active';
            indicator.textContent = '● auto-refresh: on';

            // Start time updates every second
            if (!timeUpdateInterval) {
                timeUpdateInterval = setInterval(updateTime, 1000);
            }

            // Start calendar refresh checks every 30 seconds
            autoRefreshInterval = setInterval(async () => {
                const savedURL = getCookie('calendarURL');
                if (savedURL) {
                    await checkForCalendarUpdates(savedURL);
                }
            }, 30 * 1000); // 30 seconds
        }

        function stopAutoRefresh() {
            const indicator = document.getElementById('autoRefreshIndicator');
            indicator.className = 'auto-refresh-indicator';
            indicator.textContent = '◐ auto-refresh: off';

            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
            }
            if (timeUpdateInterval) {
                clearInterval(timeUpdateInterval);
                timeUpdateInterval = null;
            }
        }

        function updateTime() {
            // Update current date and time
            const now = new Date();
            document.getElementById('currentDate').textContent = `today: ${now.toLocaleDateString('en-GB', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })}`;

            // Update current time displays in today's events with seconds
            const currentTimeElements = document.querySelectorAll('.current-time');
            const currentTime = now.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false });
            currentTimeElements.forEach(el => {
                el.textContent = currentTime;
            });

            // Refresh today's event status if we have current patterns
            if (currentPatterns) {
                refreshEventStatuses();
            }
        }

        function refreshEventStatuses() {
            const allEvents = Object.values(currentPatterns.byName).flat();
            const nextWeek = getNextWeekEvents(allEvents);
            const todayEvents = Object.values(nextWeek).find(events => {
                if (!events || events.length === 0) return false;
                const dayDate = new Date(events[0].start);
                dayDate.setHours(0, 0, 0, 0);
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                return dayDate.getTime() === today.getTime();
            });

            if (todayEvents) {
                const currentEventStatus = getCurrentEventStatus(todayEvents);
                updateEventStatusDisplay(todayEvents, currentEventStatus);
            }
        }

        function updateEventStatusDisplay(todayEvents, currentEventStatus) {
            const dayEvents = document.querySelectorAll('.day-schedule.today .day-event');
            const now = new Date();

            dayEvents.forEach((eventEl, index) => {
                const event = todayEvents[index];
                if (!event) return;

                // Reset classes
                eventEl.className = 'day-event';

                // Check for exam events and add exam class
                if (isExamEvent(event)) {
                    eventEl.classList.add('exam');
                }

                // Check if event is done
                const eventEnd = event.end || new Date(event.start.getTime() + 60 * 60 * 1000); // Default 1 hour if no end time
                if (now > eventEnd) {
                    eventEl.classList.add('done');
                    // Update indicator to show it's done
                    const indicatorEl = eventEl.querySelector('.event-indicator');
                    if (indicatorEl) {
                        indicatorEl.textContent = '';
                    } else {
                        eventEl.insertAdjacentHTML('afterbegin', '<span class="event-indicator"> </span>');
                    }
                    return;
                }

                // Apply current status
                if (currentEventStatus && currentEventStatus.event === event) {
                    eventEl.classList.add(currentEventStatus.status);

                    let indicatorEl = eventEl.querySelector('.event-indicator');
                    if (!indicatorEl) {
                        eventEl.insertAdjacentHTML('afterbegin', '<span class="event-indicator"></span>');
                        indicatorEl = eventEl.querySelector('.event-indicator');
                    }

                    indicatorEl.textContent = currentEventStatus.indicator;

                    // Update minutes until if applicable
                    let minutesEl = eventEl.querySelector('.minutes-until');
                    if (currentEventStatus.minutesUntil) {
                        if (!minutesEl) {
                            indicatorEl.insertAdjacentHTML('afterend', ' <span class="minutes-until" style="font-size: 0.7rem; color: #ffaa00;"></span>');
                            minutesEl = eventEl.querySelector('.minutes-until');
                        }
                        //minutesEl.textContent = `(in ${currentEventStatus.minutesUntil}min)`;
                    } else if (minutesEl) {
                        minutesEl.remove();
                    }
                } else {
                    // Remove indicator if not current
                    const indicatorEl = eventEl.querySelector('.event-indicator');
                    if (indicatorEl) {
                        indicatorEl.remove();
                    }
                    const minutesEl = eventEl.querySelector('.minutes-until');
                    if (minutesEl) {
                        minutesEl.remove();
                    }
                }
            });
        }

        async function checkForCalendarUpdates(url) {
            const indicator = document.getElementById('autoRefreshIndicator');
            indicator.className = 'auto-refresh-indicator checking';
            indicator.textContent = '◒ checking updates...';

            try {
                const proxyUrl = `https://corsproxy.io/?url=${encodeURIComponent(url)}`;
                const response = await fetch(proxyUrl);

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const content = await response.text();

                // Debug logging with diff check instead of hash
                console.log('=== Calendar Update Check ===');
                console.log('Content length:', content.length);

                if (window.lastCalendarContent) {
                    // Perform detailed diff check
                    const hasChanges = performDetailedDiff(window.lastCalendarContent, content);

                    if (hasChanges) {
                        // Calendar has changed, refresh the display
                        console.log('CHANGES DETECTED - Refreshing calendar');

                        indicator.className = 'auto-refresh-indicator active';
                        indicator.textContent = '↻ updating...';

                        processICSContent(content);
                        window.lastCalendarContent = content; // Store for next comparison

                        // Show brief update notification
                        showStatus('calendar updated automatically', 'success');
                        showNoChangesNotification = true; // Enable "no changes" notifications after first update

                        setTimeout(() => {
                            indicator.className = 'auto-refresh-indicator active';
                            indicator.textContent = '● auto-refresh: on';
                        }, 2000);
                    } else {
                        // No changes detected
                        console.log('NO CHANGES - Content is identical');
                        window.lastCalendarContent = content; // Store for next comparison
                        indicator.className = 'auto-refresh-indicator active';
                        indicator.textContent = '● auto-refresh: on';

                        // Show "no changes" notification only if we've had at least one update before
                        // and only occasionally (every 5th check) to avoid spam
                        if (showNoChangesNotification && Math.random() < 0.2) { // 20% chance to show notification
                            console.log('Showing "no changes" notification');
                            showStatus('calendar checked - no changes detected', 'info');
                        } else if (showNoChangesNotification) {
                            console.log('No changes detected (notification suppressed)');
                        }
                    }
                } else {
                    // First time setting the content
                    console.log('🆕 FIRST TIME - Setting initial content');
                    window.lastCalendarContent = content; // Store for next comparison
                    indicator.className = 'auto-refresh-indicator active';
                    indicator.textContent = '● auto-refresh: on';
                }
            } catch (error) {
                console.error('Auto-refresh error:', error);
                indicator.className = 'auto-refresh-indicator active';
                indicator.textContent = '● auto-refresh: on';

                // Show error notification occasionally
                if (Math.random() < 0.3) { // 30% chance to show error notification
                    showStatus('⚠️ auto-refresh connection issue - retrying...', 'error');
                }
            }
        }

        // New function to perform detailed diff analysis
        function performDetailedDiff(oldContent, newContent) {
            if (oldContent === newContent) {
                console.log('📄 Content is byte-for-byte identical');
                return false;
            }

            console.log('�� Content differs - analyzing changes...');

            // Split into lines for comparison
            const oldLines = oldContent.split('\n');
            const newLines = newContent.split('\n');

            console.log(`Old content: ${oldLines.length} lines`);
            console.log(`New content: ${newLines.length} lines`);

            const maxLines = Math.max(oldLines.length, newLines.length);
            let differences = 0;
            let significantChanges = 0;

            // Track types of changes
            const changeTypes = {
                timestamps: 0,
                sequences: 0,
                uids: 0,
                content: 0,
                lineCount: 0
            };

            for (let i = 0; i < maxLines; i++) {
                const oldLine = oldLines[i] || '';
                const newLine = newLines[i] || '';

                if (oldLine !== newLine) {
                    differences++;

                    // Analyze type of change
                    if (oldLine.startsWith('DTSTAMP:') || newLine.startsWith('DTSTAMP:')) {
                        changeTypes.timestamps++;
                        console.log(`Timestamp change on line ${i + 1}:`);
                        console.log(`  Old: ${oldLine}`);
                        console.log(`  New: ${newLine}`);
                    } else if (oldLine.startsWith('SEQUENCE:') || newLine.startsWith('SEQUENCE:')) {
                        changeTypes.sequences++;
                        console.log(`Sequence change on line ${i + 1}:`);
                        console.log(`  Old: ${oldLine}`);
                        console.log(`  New: ${newLine}`);
                    } else if (oldLine.includes('UID:') || newLine.includes('UID:')) {
                        changeTypes.uids++;
                        console.log(`UID change on line ${i + 1}:`);
                        console.log(`  Old: ${oldLine}`);
                        console.log(`  New: ${newLine}`);
                    } else if (oldLine === '' && newLine !== '' || oldLine !== '' && newLine === '') {
                        changeTypes.lineCount++;
                        console.log(`Line count change at line ${i + 1}:`);
                        console.log(`  Old: "${oldLine}"`);
                        console.log(`  New: "${newLine}"`);
                    } else {
                        changeTypes.content++;
                        significantChanges++;
                        console.log(`📝 Content change on line ${i + 1}:`);
                        console.log(`  Old: ${oldLine}`);
                        console.log(`  New: ${newLine}`);
                    }

                    // Limit detailed output to first 10 differences
                    if (differences >= 10) {
                        console.log(`... and ${maxLines - i - 1} more lines to check`);
                        break;
                    }
                }
            }

            // Summary
            console.log('=== CHANGE SUMMARY ===');
            console.log(`Total differences: ${differences}`);
            console.log(`Timestamp changes: ${changeTypes.timestamps}`);
            console.log(`Sequence changes: ${changeTypes.sequences}`);
            console.log(`UID changes: ${changeTypes.uids}`);
            console.log(`Line count changes: ${changeTypes.lineCount}`);
            console.log(`Significant content changes: ${changeTypes.content}`);

            // Determine if we should refresh based on significant changes
            const shouldRefresh = significantChanges > 0 || changeTypes.content > 0;

            if (!shouldRefresh && differences > 0) {
                console.log('🔍 Changes detected but appear to be metadata only (timestamps, sequences, UIDs)');
                console.log('🚫 Skipping refresh to preserve view state');
            }

            return shouldRefresh;
        }
        // Enhanced processICSContent to store patterns and enable auto-refresh
        function processICSContent(content) {
            try {
                const events = parseICS(content);

                if (events.length === 0) {
                    showError('calendar empty');
                    return;
                }

                currentPatterns = analyzePatterns(events);
                displayResults(currentPatterns);

                // Immediately update event statuses (done classes, exam styling) without waiting for timer
                setTimeout(() => {
                    refreshEventStatuses();
                }, 100); // Very short delay to ensure DOM is ready

                // Start auto-refresh if we have a saved URL and it's not already running
                const savedURL = getCookie('calendarURL');
                if (savedURL && !autoRefreshInterval) {
                    // Store initial content for comparison
                    window.lastCalendarContent = content;
                    startAutoRefresh();
                }
            } catch (error) {
                showError('error parsing calendar:' + error.message);
                console.error(error);
            }
        }

        // Toggle auto-refresh on indicator click
        document.addEventListener('DOMContentLoaded', function() {
            // Show mobile controls on mobile devices
            function showMobileControlsIfNeeded() {
                const isMobile = window.innerWidth <= 768;
                const mobileControls = document.querySelector('.mobile-controls');
                const desktopAutoRefresh = document.getElementById('autoRefreshIndicator');
                const desktopSettings = document.getElementById('settingsToggle');

                if (isMobile) {
                    mobileControls.style.display = 'flex';
                    desktopAutoRefresh.style.display = 'none';
                    desktopSettings.style.display = 'none';
                } else {
                    mobileControls.style.display = 'none';
                    desktopAutoRefresh.style.display = 'block';
                    desktopSettings.style.display = 'block';
                }
            }

            // Show mobile controls immediately
            showMobileControlsIfNeeded();

            // Handle window resize
            window.addEventListener('resize', showMobileControlsIfNeeded);

            // Set up mobile control event handlers
            const mobileAutoRefresh = document.getElementById('mobileAutoRefreshIndicator');
            const mobileSettings = document.getElementById('mobileSettingsToggle');

            if (mobileAutoRefresh) {
                mobileAutoRefresh.addEventListener('click', function() {
                    if (autoRefreshInterval) {
                        stopAutoRefresh();
                        this.textContent = '◐ auto-refresh: off';
                    } else {
                        const savedURL = getCookie('calendarURL');
                        if (savedURL && currentPatterns) {
                            startAutoRefresh();
                            this.textContent = '● auto-refresh: on';
                        } else {
                            showStatus('load a calendar first to enable auto-refresh', 'info');
                        }
                    }
                });
            }

            if (mobileSettings) {
                mobileSettings.addEventListener('click', function() {
                    const section = document.getElementById('settingsSection');
                    if (section.style.display === 'none' || section.style.display === '') {
                        section.style.display = 'block';
                        this.textContent = '[ hide settings ]';

                        // Load current keywords into input
                        const savedKeywords = getCookie('highlightKeywords');
                        if (savedKeywords) {
                            try {
                                const keywords = JSON.parse(savedKeywords);
                                document.getElementById('keywordsInput').value = keywords.join(', ');
                            } catch (e) {
                                console.error('Error loading keywords:', e);
                            }
                        } else {
                            document.getElementById('keywordsInput').value = 'exam, test, midterm, final';
                        }

                        setTimeout(() => {
                            section.scrollIntoView({
                                behavior: 'smooth',
                                block: 'start'
                            });
                        }, 100);
                    } else {
                        section.style.display = 'none';
                        this.textContent = '[ settings ]';
                    }
                });
            }

            // Desktop indicator click handler
            const indicator = document.getElementById('autoRefreshIndicator');
            indicator.addEventListener('click', function() {
                if (autoRefreshInterval) {
                    stopAutoRefresh();
                } else {
                    const savedURL = getCookie('calendarURL');
                    if (savedURL && currentPatterns) {
                        startAutoRefresh();
                    } else {
                        showStatus('load a calendar first to enable auto-refresh', 'info');
                    }
                }
            });
        });

        // Auto-load saved URL on page load - FIXED
        window.addEventListener('load', function() {
            const savedURL = getCookie('calendarURL');
            if (savedURL) {
                document.getElementById('urlInput').value = savedURL;
                fetchFromURL(true); // Pass true to indicate this is an auto-load
            }
        });

        // Make functions available globally
        window.fetchFromURL = fetchFromURL;

        // Settings functionality - FIXED
        document.getElementById('saveKeywordsButton').addEventListener('click', function() {
            const keywordsInput = document.getElementById('keywordsInput');
            const keywords = keywordsInput.value.split(',').map(k => k.trim()).filter(k => k !== '');

            if (keywords.length === 0) {
                showError('please enter at least one keyword.');
                return;
            }

            // Save keywords to cookie - FIXED
            setCookie('highlightKeywords', JSON.stringify(keywords), 365);
            showStatus('keywords saved! refreshing highlights...', 'success');

            // Refresh the display to apply new keywords
            if (currentPatterns) {
                setTimeout(() => {
                    displayResults(currentPatterns);
                    refreshEventStatuses();
                }, 500);
            }
        });

        document.getElementById('resetKeywordsButton').addEventListener('click', function() {
            // Reset to default keywords - FIXED
            deleteCookie('highlightKeywords');
            document.getElementById('keywordsInput').value = 'exam, test, midterm, final';
            showStatus('keywords reset to default. refreshing highlights...', 'success');

            // Refresh the display to apply default keywords
            if (currentPatterns) {
                setTimeout(() => {
                    displayResults(currentPatterns);
                    refreshEventStatuses();
                }, 500);
            }
        });

        // Load saved keywords when settings section is opened - FIXED
        document.getElementById('settingsToggle').addEventListener('click', function() {
            const section = document.getElementById('settingsSection');
            if (section.style.display === 'none' || section.style.display === '') {
                section.style.display = 'block';
                this.textContent = '[ hide settings ]';

                // Load current keywords into input - FIXED
                const savedKeywords = getCookie('highlightKeywords');
                if (savedKeywords) {
                    try {
                        const keywords = JSON.parse(savedKeywords);
                        document.getElementById('keywordsInput').value = keywords.join(', ');
                    } catch (e) {
                        console.error('Error loading keywords:', e);
                        // Fallback to default
                        document.getElementById('keywordsInput').value = 'exam, test, midterm, final';
                    }
                } else {
                    // Show default keywords
                    document.getElementById('keywordsInput').value = 'exam, test, midterm, final';
                }

                // Smoothly scroll to the settings section
                setTimeout(() => {
                    section.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }, 100); // Small delay to ensure the section is visible before scrolling
            } else {
                section.style.display = 'none';
                this.textContent = '[ settings ]';
            }
        });

        // Function to get current highlight keywords (from saved settings or default)
        function getHighlightKeywords() {
            const savedKeywords = getCookie('highlightKeywords');
            if (savedKeywords) {
                try {
                    return JSON.parse(savedKeywords);
                } catch (e) {
                    console.error('Error parsing saved keywords:', e);
                    return ['exam', 'test', 'midterm', 'final', 'quiz', 'assessment'];
                }
            }
            return ['exam', 'test', 'midterm', 'final', 'quiz', 'assessment'];
        }

        // Function to check if event contains highlight keywords
        function isExamEvent(event) {
            if (!event.summary) return false;
            const summary = event.summary.toLowerCase();
            const keywords = getHighlightKeywords();
            return keywords.some(keyword => summary.includes(keyword.toLowerCase()));
        }

        // Pattern section toggle functionality
        function togglePatternSection(sectionId) {
            const content = document.getElementById(sectionId);
            const header = content.previousElementSibling;

            if (content.classList.contains('collapsed')) {
                content.classList.remove('collapsed');
                content.style.maxHeight = content.scrollHeight + 'px';
                header.classList.remove('collapsed');
            } else {
                content.classList.add('collapsed');
                content.style.maxHeight = '0px';
                header.classList.add('collapsed');
            }
        }

        // Expand button functionality
        function toggleExpand(listId, button) {
            const list = document.getElementById(listId);
            if (list.classList.contains('collapsed')) {
                list.classList.remove('collapsed');
                button.textContent = '[ collapse ]';
            } else {
                list.classList.add('collapsed');
                button.textContent = '[ expand ]';
            }
        }

        // Make functions available globally
        window.togglePatternSection = togglePatternSection;
        window.toggleExpand = toggleExpand;
    </script>
    <footer style="
    text-align: center;
    margin-top: 50px;
    padding: 20px;
    border-top: 1px solid #2a2a2a;
    color: #666;
    font-size: 0.8rem;
">
        <div>wmr? v3.3</div>
        <div style="margin-top: 5px;">
            <a href="https://github.com/alfaoz" target="_blank" id="githubLink" style="
            color: #888;
            text-decoration: none;
            transition: all 0.3s ease;
            position: relative;
            display: inline-block;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace;
        ">
                github.com/alfaoz
            </a>
        </div>
    </footer>

    <style>
        #githubLink::before {
            content: '$ ';
            opacity: 0;
            transition: opacity 0.3s ease;
            color: #44ff44;
        }

        #githubLink::after {
            content: '_';
            animation: blink 1s infinite;
            opacity: 0;
            transition: opacity 0.3s ease;
            color: #44ff44;
            margin-left: 2px;
        }

        #githubLink:hover {
            color: #e0e0e0;
            transform: translateX(10px);
        }

        #githubLink:hover::before {
            opacity: 1;
        }

        #githubLink:hover::after {
            opacity: 1;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
    </style>
</body>

</html>
